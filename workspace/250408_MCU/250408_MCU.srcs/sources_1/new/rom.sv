`timescale 1ns / 1ps

module rom(
    input logic [31:0] addr,
    output logic [31:0] data
    );
    logic [31:0] rom[0:15];
    
    initial begin
        //rom[x] = 32'b func7 _ rs2 _ rs1 _ f3 _ rd _ opcode; // R-Type
        rom[0] = 32'b0000000_00001_00010_000_00100_0110011; 
        //add x4, x2, x1
        rom[1] = 32'b0100000_00001_00010_000_00101_0110011; 
        // sub x5, x2, x1
        rom[2] = 32'b0000000_00001_00010_110_00110_0110011;
        // OR x6, x2, x1
        rom[3] = 32'b0000000_00001_00010_111_00111_0110011;
        // AND x7, x2, x1
        rom[4] = 32'b0000000_00001_00010_001_01000_0110011;
        // SLL x8, x2, x1
        rom[5] = 32'b0000000_00001_00010_101_01001_0110011;
        // SRL x9, x2, x1
        rom[6] = 32'b0100000_00001_00010_101_01010_0110011;
        // SRA x10, x2, x1
        rom[7] = 32'b0000000_00010_00001_010_01011_0110011;
        // SLT x11, x1, x2
        rom[8] = 32'b0000000_00010_00001_011_01100_0110011;
        // SLTU x12, x1, x2
        rom[9] = 32'b0000000_00001_00010_100_01101_0110011;
        // XOR x13, x2, x1
    end

    assign data = rom[addr[31:2]]; //rom의 0번 1번을 지움, 4의 배수로 맞추기 위해
endmodule